#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WORKGROUP_SIZE 32
layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE) in;
layout (binding = 0, rgba8) uniform writeonly image2D resultImage;

layout (binding = 1) uniform UniformBufferObject {
    mat4 model;
    mat4 view;
    mat4 proj;
} ubo;

struct Intersection {
    vec3 normal;
    vec3 point;
    bool valid;
    float t;
};

// Compute sphere intersection
Intersection raySphereIntersection(in vec3 ro, in vec3 rd, in vec4 sphere) {
	Intersection isect;
    isect.valid = false;
    isect.point = vec3(0);
    isect.normal = vec3(0, 1, 0);
    
    // no rotation, always a sphere
    ro -= sphere.xyz;
    ro /= sphere.w;
    
    float A = dot(rd, rd);
    float B = 2.0 * dot(rd, ro);
    float C = dot(ro, ro) - 0.25;
    float discriminant = B * B - 4.0 * A * C;
    
    if (discriminant < 0.0) return isect;
    float t = (sqrt(discriminant) - B) / A * 0.5;
    if (t < 0.0) t = (-sqrt(discriminant) - B) / A * 0.5;
    
    if (t >= 0.0) {
        isect.valid = true;
    	vec3 p = vec3(ro + rd * t);
        isect.normal = normalize(p);
        p *= sphere.w;
        p += sphere.xyz;
        isect.point = p;
        isect.t = t;
    }
    
    return isect;
}

void main() {
	// TODO: make cloudz

    /// Extract the UV
    ivec2 dim = imageSize(resultImage);
	vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;
    uv.y = 1.0 - uv.y;

    /// Cast a ray
    
    // Compute screen space point from UVs
    vec2 screenPoint = uv * 2.0 - 1.0;
    //screenPoint.x *= dim.x / dim.y; // aspect ratio

    // Extract camera information from uniform
    vec3 camRight = vec3(ubo.view[0][0], ubo.view[0][1], ubo.view[0][2]); // should normalize these but that could slow things down
    vec3 camUp = vec3(ubo.view[1][0], ubo.view[1][1], ubo.view[1][2]);
    vec3 camLook = vec3(ubo.view[2][0], ubo.view[2][1], ubo.view[2][2]);

    // Compute ray direction
    vec3 refPoint = vec3(0);
    refPoint += screenPoint.x * camRight + screenPoint.y * camUp;
    vec3 cameraPos = -ubo.view[3].xyz;
    vec3 rayDirection = normalize(refPoint - cameraPos);

    /// Raytrace the scene (a sphere, to become the atmosphere)
    vec4 atmosphereSphere = vec4(/*cameraPos*/ vec3(0), 0.5); // centered at the camera, scale of 1.0
    Intersection atmosphereIsect = raySphereIntersection(cameraPos, rayDirection, atmosphereSphere);
    
    vec4 finalColor = vec4(atmosphereIsect.normal * float(atmosphereIsect.valid), 1);
    //vec4 finalColor = vec4(screenPoint, 0, 1);

    imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), finalColor);
}
