#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WORKGROUP_SIZE 32
layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE) in;
layout (binding = 0, rgba8) uniform writeonly image2D resultImage; // TODO: HDR

layout(binding = 1) uniform UniformCameraObject {
    mat4 view;
    mat4 proj;
    vec3 cameraPosition;
} camera;

// all of these components are calculated in SkyManager.h/.cpp
layout(set = 0, binding = 2) uniform UniformSunObject {
    
    vec4 location;
    vec4 direction;
    vec4 color;
    mat4 directionBasis;
    float intensity;
} sun;

// note: a lot of sky constants are stored/precalculated in SkyManager.h / .cpp
layout(binding = 3) uniform UniformSkyObject {
    
    vec4 betaR;
    vec4 betaV;
    float mie_directional;
} sky;

struct Intersection {
    vec3 normal;
    vec3 point;
    bool valid;
    float t;
};

#define ATMOSPHERE_RADIUS 2000000.0
#define LIGHT_VEC normalize(vec3(1, 1, 0))
#define BLOB_CLOUD_STEP_SIZE ATMOSPHERE_RADIUS / 100.0
#define NUM_FBM_OCTAVES 8
#define EPSILON 0.0001
#define PI 3.14159265
#define E 2.718281828459



#define THREE_OVER_SIXTEENPI 0.05968310365946075
#define ONE_OVER_FOURPI 0.07957747154594767

//#define VISUALIZE_NOISE

// TODO: pass fovy as a descriptor set
// Overall fovy of 45
#define FOVY_OVER_2 22.5
#define ASPECT_RATIO dim.x / dim.y

float remap(in float value, in float oldMin, in float oldMax, in float newMin, in float newMax) {
    return newMin + (((value - oldMin) / (oldMax - oldMin)) * (newMax - newMin));
}

/// TODO: proper tonemapping pipeline
// Uncharted 2 Tonemapping made by John Hable, filmicworlds.com
vec3 uc2Tonemap(vec3 x)
{
   return ((x*(0.15*x+0.1*0.5)+0.2*0.02)/(x*(0.15*x+0.5)+0.2*0.3))-0.02/0.3;
}

vec3 tonemap(vec3 x, float exposure, float invGamma, float whiteBalance) {
    vec3 white = vec3(11.2);
    vec3 color = uc2Tonemap(exposure * x);
    vec3 whitemap = 1.0 / uc2Tonemap(white);
    color *= whitemap;
    return pow(color, vec3(invGamma));
}

/// ATMOSPHERE COLOR BEGIN: adapted from open source of zz85 on Github, math from Preetham Model, initially implemented by Simon Wallner and Martin Upitis
/// Credit applies to everything before ATMOSPHERE COLOR END

// TODO: good sky uniform
#define SUN_DISTANCE 400000.0
#define RAYLEIGH 2.0
#define MIE_C 0.005
#define MIE_DG 0.8
#define TURBIDITY 5.0
#define SUN_LUMINANCE 1.0

// TODO direction on CPU instead
#define AZIMUTH 0.25
#define ELEVATION 0.25
void sunLocation(inout vec3 pos, inout vec3 dir) {
    float theta = PI * (ELEVATION - 0.5);
    float phi = 2.0 * PI * (AZIMUTH - 0.5);
    pos = SUN_DISTANCE * vec3(cos(phi), sin(phi) * sin(theta), sin(phi) * cos(theta)); // double-check this
    dir = normalize(pos);
}

// Earth shadowing constants
#define SHADOW_CUTOFF 1.6110731557
#define SHADOW_STEEPNESS 1.5
#define EE 1000.0

float sunIntensity(in float zenithAngleCos) {
    zenithAngleCos = clamp(zenithAngleCos, -1, 1);
    return EE * max(0, 1 - pow(E, -((SHADOW_CUTOFF - acos(zenithAngleCos)) / SHADOW_STEEPNESS)));
}

#define MIE_CONST vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14)
vec3 totalMie(in float T) {
    float c = (0.2 * T) * 10E-18;
    return 0.434 * c * MIE_CONST;
}

#define RAYLEIGH_TOTAL vec3(5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5)
#define SUN_ANGULAR_COS 0.999956676946448443553574619906976478926848692873900859324


float rayleighPhase(in float cosTheta) {
    return THREE_OVER_SIXTEENPI * (1.0 + cosTheta * cosTheta);
}

float hgPhase(in float cosTheta, in float g) {
    float g2 = g * g;
    float inv = 1.0 / pow(1.0 - 2.0 * g * cosTheta + g2, 1.5);
    return ONE_OVER_FOURPI * ((1.0 - g2) * inv);
}

vec3 getAtmosphereColorPhysical(in vec3 dir, inout vec3 sunDir) {
    vec3 color = vec3(0);

    // TODO START: doable on CPU
    sunDir = normalize(sun.direction.xyz); // normalized before transfer but not after?
    
    vec3 sunPos = sun.location.xyz; 

    float sunE = sun.intensity; 
    float sunFade = 1.0 - clamp(1.0  - exp( sunPos.y / 450000.0 ) , 0.0, 1.0); //
    vec3 BetaR = sky.betaR.xyz;  // RAYLEIGH_TOTAL * (RAYLEIGH - 1.0 + sunFade); // 
    vec3 BetaM = sky.betaV.xyz; // totalMie(TURBIDITY) * MIE_C; //

    // TODO END

    // optical length
    float zenith = acos(max(0.0, dir.y)); // acos?
    float inverse = 1.0 / (cos(zenith) + 0.15 * pow(93.885 - ((zenith * 180.0) / PI), -1.253));
    float sR = 8.4E3 * inverse;
    float sM = 1.25E3 * inverse;

    vec3 fex = exp( -BetaR * sR + BetaM * sM);

    float cosTheta = dot(sunDir, dir);


    float rPhase = rayleighPhase(cosTheta * 0.5 + 0.5);
    vec3 betaRTheta = BetaR * rPhase;
    //return vec3(0.5 + 0.5 * cosTheta);
    float mPhase = hgPhase(cosTheta, MIE_DG);
    //return vec3(isnan(cosTheta) ? 1.0 : 0.0);
    vec3 betaMTheta = BetaM * mPhase;

    float yDot = 1.0 - sunDir.y;
    yDot *= yDot * yDot * yDot * yDot;
    vec3 betas = (betaRTheta + betaMTheta) / (BetaR + BetaM);
    vec3 Lin = pow(sunE * (betas) * (1.0 - fex), vec3(1.5));
    Lin *= mix(vec3(1), pow(sunE * (betas) * fex, vec3(0.5)), clamp(yDot, 0.0, 1.0));

    vec3 L0 = 0.1 * fex;

    float sunDisk = smoothstep(SUN_ANGULAR_COS, SUN_ANGULAR_COS + 0.00002, cosTheta);
    L0 += (sunE * 19000.0 * fex) * sunDisk;

    color = (Lin + L0) * 0.04 + vec3(0.0, 0.0003, 0.00075);

    
    // basic tonemap for now, should do in post.
    //color = vec3(1.0) - exp(-color);
    //color = pow(color, vec3(1.0 / 2.2)); 
    return color;
}

vec3 getAtmosphereColor(in vec3 dir) {
    // TODO: physical algorithm
    vec3 up = mix(vec3(0.3, 0.7, 1.0), vec3(0.15, 0.65, 0.9), dir.y);
    vec3 down = vec3(0.8, 0.9, 1.0);
    float y = dir.y;
    y = smoothstep(0, 1, clamp(remap(y, 0, 0.1, 0, 1), 0, 1));
    return mix(down, up, y);
}


/// ATMOSPHERE COLOR END: see credit at BEGIN




// Compute sphere intersection
Intersection raySphereIntersection(in vec3 ro, in vec3 rd, in vec4 sphere) {
	Intersection isect;
    isect.valid = false;
    isect.point = vec3(0);
    isect.normal = vec3(0, 1, 0);
    
    // no rotation, only uniform scale, always a sphere
    ro -= sphere.xyz;
    ro /= sphere.w;
    
    float A = dot(rd, rd);
    float B = 2.0 * dot(rd, ro);
    float C = dot(ro, ro) - 0.25;
    float discriminant = B * B - 4.0 * A * C;
    
    if (discriminant < 0.0) return isect;
    float t = (-sqrt(discriminant) - B) / A * 0.5;
    if (t < 0.0) t = (sqrt(discriminant) - B) / A * 0.5;
    
    if (t >= 0.0) {
        isect.valid = true;
    	vec3 p = vec3(ro + rd * t);
        isect.normal = normalize(p);
        p *= sphere.w;
        p += sphere.xyz;
        isect.point = p;
        isect.t = length(p - ro);
    }
    
    return isect;
}

// Procedural noise function for Fractal Brownian Motion taken from here: https://thebookofshaders.com/13/
float noise(in vec2 p) { 
    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453123);
}

float interpolateNoise(in vec2 p) {
    vec2 p_floor = floor(p);
    vec2 p_fract = p - p_floor;

    // Sample the noise function at grid intervals
    vec2 offset = vec2(0.0, 1.0);
    float noise00 = noise(p_floor);
    float noise01 = noise(p_floor + offset);
    float noise10 = noise(p_floor + offset.yx);
    float noise11 = noise(p_floor + offset.yy);

    // Bilinearly interpolate
    float noise_x1 = mix(noise00, noise10, p_fract.x);
    float noise_x2 = mix(noise01, noise11, p_fract.x);

    return mix(noise_x1, noise_x2, p_fract.y);
}

float FBM(in vec2 p) {
    float amplitude = 0.75;
    float frequency = 1.0;
    const float persistence = 0.5;
    float maxVal = 0.0;
    float accumNoise = 0.0;

    for(int i = 0; i < NUM_FBM_OCTAVES; ++i) {
        accumNoise += interpolateNoise(p * frequency) * amplitude;
        maxVal += amplitude;
        amplitude *= persistence;
        frequency *= 2.0;
    }

    float noiseVal = accumNoise / maxVal;
    noiseVal *= step(0.5, noiseVal);
    return max(0.0, remap(noiseVal, 0.5, 1.0, 0.0, 0.9));
}

void main() {
    /// Extract the UV
    ivec2 dim = imageSize(resultImage); // prob better as uniform
    // TODO: half resolution reprojection
    // TODO: ? quarter resolution reprojection ?
	vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;
    
    /// Cast a ray
    // Compute screen space point from UVs
    vec2 screenPoint = uv * 2.0 - 1.0;

    // Extract camera information from uniform
    vec3 camLook = vec3(camera.view[0][2], camera.view[1][2], camera.view[2][2]);
    vec3 camRight = vec3(camera.view[0][0], camera.view[1][0], camera.view[2][0]);
    vec3 camUp = vec3(camera.view[0][1], camera.view[1][1], camera.view[2][1]);

    // Compute ray direction
    vec3 cameraPos = camera.cameraPosition;
    vec3 refPoint = cameraPos - camLook;

    const float tanFovy = 0.4142135; // TODO link camera uniform

    vec3 p = refPoint + ASPECT_RATIO * screenPoint.x * tanFovy * camRight - screenPoint.y * tanFovy * camUp; // TODO: aspect ratio as uniform

    vec3 rayDirection = normalize(p - cameraPos);

    vec3 sunDir;

    vec3 backgroundCol = getAtmosphereColorPhysical(rayDirection, sunDir);
    //backgroundCol = mix(backgroundCol, rayDirection * 0.5 + 0.5, 0.5);

    // It is likely we will never have an entirely unobstructed view of the horizon, so kill rays that would otherwise be executing.
    // TODO: low-res stencil check first
    if(dot(rayDirection, vec3(0, 1, 0)) < 0.0) {
        backgroundCol = tonemap(backgroundCol, 1.0, 1.0 / 2.2, 11.2); // TODO remove tonemap
        imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(backgroundCol, 1));
        return;
    }


    /// Raytrace the scene (a sphere, to become the atmosphere)
    vec3 earthCenter = cameraPos;
    earthCenter.y = -ATMOSPHERE_RADIUS * 0.5 * 0.99;
    vec4 atmosphereSphereInner = vec4(earthCenter, ATMOSPHERE_RADIUS);
    vec4 atmosphereSphereOuter = vec4(earthCenter, ATMOSPHERE_RADIUS * 1.01);
    Intersection atmosphereIsectInner = raySphereIntersection(cameraPos, rayDirection, atmosphereSphereInner);
    Intersection atmosphereIsectOuter = raySphereIntersection(cameraPos, rayDirection, atmosphereSphereOuter);

    float cosToSun = smoothstep(0.0, 1.0, clamp(dot(rayDirection, sunDir) + 1.0, 0.0, 1.0));
    cosToSun = remap(cosToSun, 0.0, 1.0, 0.1, 1.0);

    float t;
    float accumDensity = 0.0;
    float transmittance = 1.0;
    float numSteps = floor(mix(32, 64, 1.0 - rayDirection.y)); // Paper lists range more like 50 - 80
    float stepSize = (atmosphereIsectOuter.t - atmosphereIsectInner.t) / numSteps;

    // TODO: need good way to randomly sample in cone
    mat3 basis = mat3(sun.directionBasis);
    vec3 samples[6] = {
        basis * vec3(0, 0.1, 0),
        basis * vec3(0, 0.5, 0),
        basis * vec3(0, 1, 0),
        basis * vec3(0, 1.5, 0),
        basis * vec3(0, 2, 0),
        basis * vec3(0, 4, 0),
    };

    for(float t = atmosphereIsectInner.t; t < atmosphereIsectOuter.t; t += stepSize) {
        vec3 currentPos = cameraPos + t * rayDirection;
        
        // TODO: make low-res and hi-res density sample functions
        vec3 fromCenter = normalize(currentPos - earthCenter);
        // Sample is read from XZ of bounding sphere. Maybe there's a better way, but we'll never see the equator, so...
        vec3 sampleProjected = 0.5 * ATMOSPHERE_RADIUS * fromCenter + earthCenter;

        float cumulus = length(currentPos - sampleProjected) / (0.5 * ATMOSPHERE_RADIUS * 0.01); // radial distance from inner to outer shell, normalized
        cumulus = clamp(cumulus, 0, 1);
        cumulus = remap(cumulus, 0.0, 0.3, 0.0, 1.0) * remap(cumulus, 0.7, 1.0, 1.0, 0.0); // TODO: remap based on cloud type, not just cumulus

        vec2 samplePoint = (sampleProjected.xz - cameraPos.xz) / 10000.0;
        float density = cumulus * FBM(samplePoint); // TODO: placement texture as described in paper

        if (density > 0.00) {
            float densityAlongLight = 0.0;

            // Sample light propogation for Beer's law in a cone towards the light
            for (int i = 0; i < 6; i++) {
                vec3 lightSamplePoint = currentPos + 6.0 * stepSize * samples[i];
                vec3 lightSamplePointProj = 0.5 * ATMOSPHERE_RADIUS * normalize(lightSamplePoint - earthCenter) + earthCenter;
                float cumulus2 = length(lightSamplePoint - lightSamplePointProj)  / (0.5 * ATMOSPHERE_RADIUS * 0.01); 
                cumulus2 = remap(clamp(cumulus2, 0, 1), 0.0, 0.3, 0.0, 1.0) * remap(clamp(cumulus2, 0, 1), 0.7, 1.0, 1.0, 0.0);
                densityAlongLight += cumulus2 * FBM((lightSamplePoint.xz - cameraPos.xz) / 10000.0);
            }
        
            // Beer's Law with extra / artistic light penetration, blend with front-to-back opacity
            transmittance = mix(transmittance,  cosToSun * (max(exp(-densityAlongLight), 0.7 * exp(-0.25 * densityAlongLight))), (1.0 - accumDensity));

            // Opacity
            
        }

        accumDensity += density;         
        if(accumDensity > 0.99) {
            accumDensity = 1.0;
            break;
        }
    }

    // opacity fades to prevent hard cutoff at horizon
    accumDensity *= smoothstep(0, 1, min(1, remap(rayDirection.y, 0, 0.1, 0, 1)));
    vec3 cSunColor = mix(sun.color.xyz * 5.0, backgroundCol, 0.0);
    vec3 cloudColor = cSunColor * clamp(transmittance, 0.0, 1.0);


    vec4 finalColor = vec4(mix(backgroundCol, cloudColor, accumDensity), 1.0);

    // TODO remove tonemap
    finalColor.xyz = tonemap(finalColor.xyz, 1.0, 1.0 / 2.2, 11.2);

    imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), finalColor);
}
